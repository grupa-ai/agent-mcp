import unittest
import logging
from typing import Optional
import sys
import os

# Adjust Python path
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)

from payment_interface import PaymentInterface
from payment_agent_discovery import PaymentAgentDiscovery
from payment_processor import PaymentProcessor

# Import all adapter classes for use as mock agents
from l402_adapter import L402Adapter
from stripe_adapter import StripeAdapter
from paypal_adapter import PaypalAdapter
from coinbase_adapter import CoinbaseAdapter
from poof_adapter import PoofAdapter
from mcp_payment_adapter import MCPPaymentAdapter

# Global mock instances - initialized in setUp methods where needed
mock_l402_agent = None
mock_stripe_agent = None
mock_paypal_agent = None

# def setUpModule():
#     """Disable logging below CRITICAL for cleaner test output."""
#     # Disabling logs globally can interfere with assertLogs, removing for now
#     # logging.disable(logging.CRITICAL)
#     pass

# def tearDownModule():
#     """Re-enable logging after tests."""
#     # logging.disable(logging.NOTSET)
#     pass


class TestPaymentAgentDiscovery(unittest.TestCase):
    def setUp(self):
        self.discovery = PaymentAgentDiscovery()
        # It's good practice to create fresh mocks for each test method if they are modified,
        # but for registration testing, these can be class members if not mutated by registration itself.
        global mock_l402_agent, mock_stripe_agent, mock_paypal_agent
        mock_l402_agent = L402Adapter()
        mock_stripe_agent = StripeAdapter(api_key="sk_mock_discovery_test")
        mock_paypal_agent = PaypalAdapter(client_id="paypal_discovery_id", client_secret="paypal_discovery_secret")


    def test_register_agent(self):
        self.discovery.register_agent("l402", mock_l402_agent)
        self.assertIn("l402", self.discovery.agents)
        self.assertEqual(self.discovery.agents["l402"], mock_l402_agent)
        self.assertEqual(self.discovery.list_agents(), ["l402"])

        # Test re-registration (overwrite)
        new_l402_mock_agent = L402Adapter() # A different instance
        with self.assertLogs(logger='payment_agent_discovery', level='WARNING') as cm:
            self.discovery.register_agent("l402", new_l402_mock_agent)
        self.assertIn("Agent 'l402' is already registered. Overwriting.", cm.output[0])
        self.assertEqual(self.discovery.agents["l402"], new_l402_mock_agent)


        # Test registering an invalid object
        class NotAnAgent:
            pass
        invalid_agent_instance = NotAnAgent()
        with self.assertRaisesRegex(TypeError, "must implement PaymentInterface"):
            self.discovery.register_agent("invalid", invalid_agent_instance)

    def test_get_agent(self):
        self.discovery.register_agent("stripe", mock_stripe_agent)
        retrieved_agent = self.discovery.get_agent("stripe")
        self.assertIsInstance(retrieved_agent, StripeAdapter)
        self.assertEqual(retrieved_agent, mock_stripe_agent)

        non_existent_agent = self.discovery.get_agent("non_existent")
        self.assertIsNone(non_existent_agent)

    def test_list_agents(self):
        # Test with no agents
        self.assertEqual(self.discovery.list_agents(), [])

        self.discovery.register_agent("l402", mock_l402_agent)
        self.discovery.register_agent("stripe", mock_stripe_agent)
        self.discovery.register_agent("paypal", mock_paypal_agent)

        agent_names = self.discovery.list_agents()
        self.assertCountEqual(agent_names, ["l402", "stripe", "paypal"]) # Order doesn't matter


class TestPaymentProcessor(unittest.TestCase):
    def setUp(self):
        self.discovery = PaymentAgentDiscovery()

        global mock_l402_agent, mock_stripe_agent
        mock_l402_agent = L402Adapter()
        mock_stripe_agent = StripeAdapter(api_key="sk_mock_processor_test")

        self.discovery.register_agent("l402", mock_l402_agent)
        self.discovery.register_agent("stripe", mock_stripe_agent)

        self.processor = PaymentProcessor(agent_discovery=self.discovery)

        # Mock payment IDs that would be generated by the adapters
        self.mock_l402_payment_id = "mock_l402_payment_proc_test_123"
        self.mock_stripe_payment_id = "pi_mock_proc_test_xyz"

    def test_initiate_payment_valid_agent(self):
        stripe_details = {'customer_id': 'cus_proc_test', 'description': 'Processor Stripe Test'}
        # Expected response from StripeAdapter.initiate_payment
        # We can call it directly to get the structure if it's complex, or construct manually
        expected_response_structure = mock_stripe_agent.initiate_payment(10.0, "USD", stripe_details)

        response = self.processor.initiate_payment("stripe", 10.0, "USD", stripe_details)

        self.assertEqual(response['status'], expected_response_structure['status'])
        self.assertTrue(response['payment_id'].startswith("pi_mock_"))
        self.assertEqual(response['provider_response']['amount_received'], 1000) # Stripe specific
        # self.assertDictContainsSubset(expected_response_structure['provider_response'], response['provider_response'])
        # Instead of comparing the whole dict due to UUIDs, check key elements:
        self.assertIn('stripe_payment_intent_id', response['provider_response'])
        self.assertTrue(response['provider_response']['stripe_payment_intent_id'].startswith('pi_mock_'))
        self.assertIn('stripe_charge_id', response['provider_response'])
        self.assertTrue(response['provider_response']['stripe_charge_id'].startswith('ch_mock_'))
        self.assertEqual(response['provider_response']['amount_received'], expected_response_structure['provider_response']['amount_received'])


    def test_initiate_payment_invalid_agent(self):
        response = self.processor.initiate_payment("unknown_agent", 1.0, "EUR", {})
        self.assertEqual(response['status'], 'error')
        self.assertIn("Payment agent 'unknown_agent' not found", response['message'])

    def test_initiate_payment_agent_exception(self):
        # Test that if an agent's method raises an exception, processor handles it
        class FailingAdapter(PaymentInterface):
            def initiate_payment(self, amount: float, currency: str, payment_details: dict) -> dict:
                raise ValueError("Simulated payment failure in adapter")
            def check_payment_status(self, payment_id: str) -> dict: return {}
            def process_refund(self, payment_id: str, amount: Optional[float] = None) -> dict: return {}

        failing_agent = FailingAdapter()
        self.discovery.register_agent("failing_agent", failing_agent)

        response = self.processor.initiate_payment("failing_agent", 10.0, "USD", {})
        self.assertEqual(response['status'], 'error')
        self.assertIn("Error during 'failing_agent' payment initiation: Simulated payment failure in adapter", response['message'])


    def test_check_payment_status_valid_agent(self):
        # Expected response from L402Adapter.check_payment_status
        expected_response = mock_l402_agent.check_payment_status(self.mock_l402_payment_id)

        response = self.processor.check_payment_status("l402", self.mock_l402_payment_id)
        self.assertEqual(response, expected_response)
        self.assertEqual(response['status'], 'paid') # Based on L402Adapter mock

    def test_check_payment_status_invalid_agent(self):
        response = self.processor.check_payment_status("unknown_agent", "any_id")
        self.assertEqual(response['status'], 'error')
        self.assertIn("Payment agent 'unknown_agent' not found", response['message'])

    def test_process_refund_valid_agent(self):
        # Expected response from StripeAdapter.process_refund
        expected_response = mock_stripe_agent.process_refund(self.mock_stripe_payment_id, 5.0)

        response = self.processor.process_refund("stripe", self.mock_stripe_payment_id, 5.0)
        # self.assertEqual(response, expected_response) # Avoid this due to UUIDs
        self.assertEqual(response['status'], expected_response['status'])
        self.assertTrue(response['refund_id'].startswith("re_mock_"))
        self.assertEqual(response['provider_response']['amount_refunded'], expected_response['provider_response']['amount_refunded'])
        self.assertIn('stripe_refund_id', response['provider_response'])
        self.assertTrue(response['provider_response']['stripe_refund_id'].startswith("re_mock_"))

    def test_process_refund_invalid_agent(self):
        response = self.processor.process_refund("unknown_agent", "any_id", 5.0)
        self.assertEqual(response['status'], 'error')
        self.assertIn("Payment agent 'unknown_agent' not found", response['message'])

    def test_constructor_type_error(self):
        with self.assertRaisesRegex(TypeError, "agent_discovery must be an instance of PaymentAgentDiscovery"):
            PaymentProcessor(agent_discovery="not_a_discovery_instance")


if __name__ == '__main__':
    unittest.main()
